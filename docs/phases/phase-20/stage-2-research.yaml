# =============================================================================
# PHASE 20: SCAFFOLD FOUNDATION & CONVENTIONS
# STAGE 2: RESEARCH
# =============================================================================

metadata:
  phase: 20
  phaseName: "ScaffoldFoundation"
  stage: 2
  stageName: "research"
  created: "2026-01-20T16:41:00Z"
  previousStage: "stage-1-discovery.yaml"
  gateApproval:
    from: "discovery"
    to: "research"
    approvedAt: "2026-01-20T16:40:59Z"
    approver: "Matthew Phipps"
  status: "in-progress"

# =============================================================================
# LOCKED FILE AUDIT (LEAP-034)
# =============================================================================

lockedFileAudit:
  summary: "8 locked files reviewed for extension gaps"
  
  findings:
    # -------------------------------------------------------------------------
    # CORE JS FILES
    # -------------------------------------------------------------------------
    
    stateJs:
      file: "core/state.js"
      lines: 161
      extensionNeeded: true
      extensionGap: "CRITICAL"
      
      problem: |
        state.js manages only 3 scaffold keys: user, theme, sidebarCollapsed.
        Factory features need to add their own state (e.g., incidents, chat, filters).
        File is locked, so features cannot modify it.
        
      currentWorkaround: |
        v2.0.2 Factory created parallel state in incident-service.js with:
        - Local state object
        - Local subscriber pattern
        - Manual notification
        This fragments state management across the codebase.
        
      solution: "registerStateSlice() API - see stateExtensionDesign below"
      
    firebaseJs:
      file: "core/firebase.js"
      lines: 72
      extensionNeeded: false
      extensionGap: "NONE"
      
      analysis: |
        Firebase provides standard Firebase services: auth, db.
        Features use these exports directly via import.
        No extension mechanism needed - standard dependency injection pattern.
        
    constantsJs:
      file: "core/constants.js"
      lines: 50
      extensionNeeded: false
      extensionGap: "NONE"
      
      analysis: |
        Exports APP_NAME, APP_VERSION, ENV, isDev, isProd.
        Features that need constants can define their own in feature folder.
        Core constants are scaffold-level, not feature-level.
        Pattern: Feature constants in features/{name}/constants.js
        
    loggerJs:
      file: "core/logger.js"
      lines: 134
      extensionNeeded: false
      extensionGap: "NONE"
      
      analysis: |
        Provides debug, info, warn, error functions.
        Features use these directly via import - no extension needed.
        Log level already configurable via setLogLevel().

    # -------------------------------------------------------------------------
    # CSS FILES
    # -------------------------------------------------------------------------
    
    variablesCss:
      file: "ui/styles/variables.css"
      lines: 104
      extensionNeeded: false
      extensionGap: "NONE"
      
      analysis: |
        CSS custom properties in :root.
        Extension pattern: CSS cascade - later stylesheets can override/add.
        Features add their own variables in component CSS files.
        Light theme already demonstrates override pattern (.light-theme class).
        
    baseCss:
      file: "ui/styles/base.css"
      extensionNeeded: false
      extensionGap: "NONE"
      reason: "Provides reset and global styles. Component CSS extends naturally via cascade."
      
    buttonsCss:
      file: "ui/styles/buttons.css"
      extensionNeeded: false
      extensionGap: "NONE"
      reason: "Button patterns. Components can add new button classes in their own CSS."
      
    inputsCss:
      file: "ui/styles/inputs.css"
      extensionNeeded: false
      extensionGap: "NONE"
      reason: "Input patterns. Components can add new input classes in their own CSS."

  conclusion: |
    Only state.js requires an extension mechanism.
    All other locked files are either:
    - Used as-is via import (firebase, logger, constants)
    - Extended via CSS cascade (all CSS files)
    
    Recommendation: Implement LEAP-032 (state extension) only.
    Mark LEAP-034 as complete after documenting this finding.

# =============================================================================
# STATE EXTENSION DESIGN (LEAP-032)
# =============================================================================

stateExtensionDesign:
  
  approach: "Slice Registration Pattern"
  
  apiDesign:
    registerSlice:
      signature: "registerStateSlice(name, initialState, setters)"
      purpose: "Register a feature's state slice with the global state manager"
      params:
        name: "String - unique slice name (e.g., 'incidents', 'chat')"
        initialState: "Object - initial state for this slice"
        setters: "Object - { setterName: (state, payload) => newState }"
      returns: "Object - { getters, setters } for this slice"
      example: |
        const { getIncidents, setIncidents } = registerStateSlice('incidents', {
          items: [],
          loading: false,
          selected: null
        }, {
          setIncidents: (state, items) => ({ ...state, items }),
          setLoading: (state, loading) => ({ ...state, loading }),
          setSelected: (state, id) => ({ ...state, selected: id })
        });
    
    getSlice:
      signature: "getState('sliceName') or getState('sliceName.key')"
      purpose: "Retrieve slice state via existing getState function"
      behavior: |
        - getState() returns full state including slices
        - getState('incidents') returns incidents slice
        - getState('incidents.items') returns items array
    
    subscribe:
      behavior: |
        Existing subscribe() continues to work.
        Subscribers are notified when ANY slice changes.
        Source parameter indicates which slice/setter triggered change.
  
  implementationPlan:
    codeLocation: "GoldSource/scaffold/core/state.js"
    approach: "Extend existing state.js with slice registry"
    linesEstimate: "~50 new lines"
    
    newExports:
      - "registerStateSlice(name, initialState, setters)"
    
    internalChanges:
      - "Add slices = {} registry object"
      - "Modify getState() to check slices first"
      - "Add registerStateSlice() function"
      - "Setters auto-wrapped to call notifySubscribers"
    
    backwardsCompatible: true
    note: "Existing code using setUser, setTheme, etc. continues to work unchanged"

  extensionPointDocumentation:
    location: "GoldSource/meta/architectural-standards.yaml"
    section: "stateExtensionPattern"
    contents:
      - "How to use registerStateSlice()"
      - "State naming conventions"
      - "Setter patterns"
      - "Subscriber best practices"

# =============================================================================
# PATH DEPTH RESEARCH (LEAP-029)
# =============================================================================

pathDepthResearch:
  
  purpose: "Document relative import depths to prevent 404 errors"
  
  scaffoldStructure:
    - path: "scaffold/"
      depth: 0
      note: "Root of scaffold"
    
    - path: "scaffold/core/"
      depth: 1
      toCore: "./"
      example: "state.js imports from './logger.js'"
    
    - path: "scaffold/features/{name}/"
      depth: 2
      toCore: "../../core/"
      example: "incident-service.js imports from '../../core/state.js'"
    
    - path: "scaffold/ui/components/{name}/"
      depth: 3
      toCore: "../../../core/"
      example: "header-ui.js imports from '../../../core/state.js'"
    
    - path: "scaffold/ui/styles/"
      depth: 2
      toCore: "../../core/"
      note: "CSS files, not JS - no imports"
  
  verifiedFrom: "GoldSource/scaffold/ui/components/header/header-ui.js line 11"
  verifiedPath: "import { getState, subscribe } from '../../../core/state.js';"
  
  documentation:
    location: "GoldSource/meta/ARCHITECTURE.yaml"
    section: "pathDepths"

# =============================================================================
# CONVENTION PATTERNS RESEARCH
# =============================================================================

conventionPatterns:

  mockDataStrategy:
    backlogItem: "LEAP-004"
    
    research:
      v101Pattern: "Separate file: incident-data.js in features/incident/"
      v102Pattern: "Extended mock-data.js in scaffold/data/"
      scaffoldCurrent: "No mock-data.js in Gold Source v2.0"
    
    recommendation:
      pattern: "Feature-specific data files"
      location: "features/{name}/{name}-data.js"
      rationale: |
        - Keeps feature self-contained
        - No modification of scaffold files
        - Matches locked file philosophy
    
    documentIn: "architectural-standards.yaml"

  stateShapesPattern:
    backlogItem: "LEAP-012"
    
    research:
      nested: "incidents: { items: [], selected: null }"
      sibling: "incidentItems: [], incidentSelected: null"
      v101: "Used sibling (state.incidentItems, state.incidentChat)"
      v102: "Used nested (incidents.items, incidents.chat)"
    
    recommendation:
      pattern: "Nested with slice as namespace"
      example: "registerStateSlice('incidents', { items: [], selected: null })"
      rationale: |
        - Slice registration enforces nesting
        - Clear ownership of state keys
        - Avoids naming collisions
    
    documentIn: "architectural-standards.yaml"

  statusEnumValues:
    backlogItem: "LEAP-017"
    
    research:
      v101: "lowercase: 'active', 'resolved', 'critical'"
      v102: "Title Case: 'Active', 'Resolved', 'Critical'"
      v103: "lowercase: 'active', 'resolved'"
    
    recommendation:
      pattern: "lowercase for status values"
      examples: ["active", "resolved", "critical", "pending"]
      rationale: |
        - Simpler comparisons (no case sensitivity issues)
        - Matches HTML data attributes
        - More common in JS conventions
    
    documentIn: "architectural-standards.yaml"

  serviceFunctionPatterns:
    backlogItem: "LEAP-016"
    
    research:
      existing: "get..., set..., handle..., render..., calculate..."
      missing: "load..., open..., close..., send..."
    
    recommendation:
      patterns:
        - prefix: "load{Entity}..."
          use: "Async data fetching (loadIncidents, loadUserProfile)"
        - prefix: "open{Thing}..."
          use: "Show UI elements (openDialog, openPanel)"
        - prefix: "close{Thing}..."
          use: "Hide UI elements (closeDialog, closePanel)"
        - prefix: "send{Action}..."
          use: "Dispatch actions (sendMessage, sendNotification)"
    
    documentIn: "architectural-standards.yaml (codeHygieneRules.namingConventions)"

  aiServicePattern:
    backlogItem: "LEAP-027"
    
    research:
      v200: "Dedicated ai-service.js in features/ai/"
      v201: "Inline AI suggestions in data file"
    
    recommendation:
      pattern: "Dedicated AI service for reusable AI logic"
      decisionTree:
        dedicatedService:
          - "Multiple features use AI"
          - "AI logic is complex (multiple prompts, conversation)"
          - "AI results need caching"
        inlineApproach:
          - "Single use case"
          - "Simple prompt/response"
          - "Prototype/demo only"
    
    documentIn: "architectural-standards.yaml"

  componentInitPattern:
    backlogItem: "LEAP-031"
    
    research:
      lazyInit: "Create DOM on first use (v2.0.0 dialog pattern)"
      explicitInit: "Create DOM in initComponent() called from app.js"
    
    recommendation:
      pattern: "Explicit init for scaffold components, lazy for dynamic content"
      
      explicitWhen:
        - "Component always visible on page load"
        - "Component is part of shell (header, sidebar, canvas)"
        - "Component needs state subscription at startup"
      
      lazyWhen:
        - "Component is modal/dialog (created when opened)"
        - "Component is dynamic list item"
        - "Component is conditionally shown"
    
    documentIn: "architectural-standards.yaml"

# =============================================================================
# RESEARCH COMPLETION
# =============================================================================

researchCompletion:
  
  questionsAnswered:
    - question: "What API pattern for registerStateSlice()?"
      answer: "registerStateSlice(name, initialState, setters) returning { getters, setters }"
    
    - question: "Should slices be namespaced or flat?"
      answer: "Namespaced via getState('sliceName') and getState('sliceName.key')"
    
    - question: "What extension patterns exist for CSS files?"
      answer: "CSS cascade - no extension mechanism needed, cascade inherently allows extension"
    
    - question: "Does firebase.js or other locked files need extension mechanisms?"
      answer: "No - only state.js needs extension. Others are used as-is or extended via patterns."

  filesReviewed:
    - "GoldSource/scaffold/core/state.js (161 lines)"
    - "GoldSource/scaffold/core/firebase.js (72 lines)"
    - "GoldSource/scaffold/core/constants.js (50 lines)"
    - "GoldSource/scaffold/core/logger.js (134 lines)"
    - "GoldSource/scaffold/ui/styles/variables.css (104 lines)"
    - "GoldSource/meta/ARCHITECTURE.yaml (231 lines)"
    - "GoldSource/meta/architectural-standards.yaml (419 lines)"
    - "FactoryTestRuns/factory-comparison-v2.0.1-vs-v2.0.2.yaml"

# =============================================================================
# NEXT STAGE
# =============================================================================

nextStage:
  name: "analysis"
  requires: "!Proceed"
  focus: "Risk assessment and approach confirmation"
